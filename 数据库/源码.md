# 数据库实验源码
## 实训1-MySQL-数据库、表与完整性约束的定义(Create)
### 第2关：创建表及表的主码约束
```
USE TestDb;
DROP TABLE IF EXISTS t_emp;
CREATE TABLE IF NOT EXISTS t_emp (
    id INT PRIMARY KEY COMMENT '员工编号',
    name VARCHAR(32) COMMENT '员工名称',
    deptId INT COMMENT '所在部门编号',
    salary FLOAT COMMENT '工资'
);
```
### 第3关：创建外码约束(foreign key)
```
USE MyDb;
DROP TABLE IF EXISTS staff;
DROP TABLE IF EXISTS dept;
CREATE TABLE if NOT exists dept(
    deptNo INT PRIMARY KEY,
    deptName VARCHAR(32)
)COMMENT '部门';
CREATE Table if NOT exists staff(
    staffNo INT PRIMARY KEY,
    staffName VARCHAR(32),
    gender CHAR(1),
    dob DATE,
    salary numeric(8,2),
    deptNo INT,
    CONSTRAINT FK_staff_deptNo FOREIGN KEY(deptNo) REFERENCES dept(deptNo)
)COMMENT '职工';
```
### 第4关：CHECK约束
```
DROP DATABASE IF EXISTS MyDb;
CREATE DATABASE MyDb;
USE MyDb;
DROP TABLE IF EXISTS products;
CREATE TABLE if NOT exists products(
    pid CHAR(10) PRIMARY KEY,
    name VARCHAR(32),
    brand CHAR(10) constraint CK_products_brand CHECK(brand in ('A','B')),
    price INT constraint CK_products_price CHECK(price > 0)
);
```
### 第5关：DEFAULT约束
```
USE MyDb;
DROP TABLE IF EXISTS hr;
CREATE TABLE if NOT exists hr(
    id CHAR(10) PRIMARY KEY,
    name VARCHAR(32) NOT NULL,
    mz CHAR(16) DEFAULT '汉族'
);
```
### 第6关：UNIQUE约束
```
USE MyDb;
DROP TABLE IF EXISTS s;
CREATE TABLE if NOT exists s(
    sno CHAR(10) PRIMARY KEY,
    name VARCHAR(32) NOT NULL,
    ID CHAR(18) UNIQUE
);
```
## 实训2-MySQL-表结构与完整性约束的修改(ALTER)
### 第1关：修改表名
将表名your_table更改为my_table

`alter table your_table rename my_table;`
### 第2关：添加与删除字段
删除表orderDetail中的列orderDate

`alter table orderDetail drop orderDate;`

添加列unitPrice

`alter table orderDetail add unitPrice numeric(10,2);`
### 第3关：修改字段
对表addressBook作以下修改：
- 将QQ号的数据类型改为char(12);
- 将列名weixin改为wechat。

`alter table addressBook modify QQ char(12),rename column weixin to wechat;`
### 第4关：添加、删除与修改约束

- 为表Staff添加主码

`alter table Staff add primary key(staffNo);`

- Dept.mgrStaffNo是外码，对应的主码是Staff.staffNo,请添加这个外码，名字为FK_Dept_mgrStaffNo

`alter table Dept add constraint FK_Dept_mgrStaffNo FOREIGN key(mgrStaffNo) references Staff(staffNo);`
- Staff.dept是外码，对应的主码是Dept.deptNo. 请添加这个外码，名字为FK_Staff_dept

`alter table Staff add constraint FK_Staff_dept foreign key(dept) references Dept(deptNo);`
- 为表Staff添加check约束，规则为：gender的值只能为F或M；约束名为CK_Staff_gender

`alter table Staff add constraint CK_Staff_gender check(gender in ('F','M'));`
- 为表Dept添加unique约束：deptName不允许重复。约束名为UN_Dept_deptName

`alter table Dept add constraint UN_Dept_deptName unique(deptName);`

## 实训3-MySQL-基于金融应用的数据查询(Select)
### 第1关：金融应用场景介绍,查询客户主要信息
查询所有客户的名称、手机号和邮箱信息。查询结果按照客户编号排序。

```
select c_name,c_phone,c_mail 
from client 
order by c_id;
```

### 第2关：邮箱为null的客户
查询客户表(client)中邮箱信息为null的客户的编号、名称、身份证号、手机号。

```
select c_id,c_name,c_id_card,c_phone 
from client 
where c_mail is null;
```

### 第3关：既买了保险又买了基金的客户
查询既买了保险又买了基金的客户的名称、邮箱和电话。结果依c_id排序。

```
SELECT c_name, c_mail, c_phone 
FROM client
WHERE c_id in (
    SELECT pro_c_id
    FROM property  
    WHERE pro_type = 2
)and c_id in (
    SELECT pro_c_id
    FROM property  
    WHERE pro_type = 3
)
ORDER BY c_id;
```

### 第4关：办理了储蓄卡的客户信息
查询办理了储蓄卡的客户名称、手机号、银行卡号。 查询结果结果依客户编号排序。

```
select c_name,c_phone,b_number
from bank_card,client
where b_c_id = c_id 
    and b_type = '储蓄卡'
order by c_id;
```

### 第5关：每份金额在30000～50000之间的理财产品
查询理财产品中每份金额在30000～50000之间的理财产品的编号,每份金额，理财年限，并按照金额升序排序，金额相同的按照理财年限降序排序。

```
select p_id,p_amount,p_year
from finances_product
where p_amount between 30000 and 50000
order by p_amount asc,p_year desc;
```

### 第6关：商品收益的众数
查询资产表中所有资产记录里商品收益的众数和它出现的次数。

```
select 
    pro_income,
    count(*) presence
from property
group by pro_income
having count(*)>=all(
    select count(*)
    from property
    group by pro_income
);
```

### 第7关：未购买任何理财产品的武汉居民
查询身份证隶属武汉市没有买过任何理财产品的客户的名称、电话号、邮箱。

```
select c_name,c_phone,c_mail
from client
where c_id_card like '4201%'
and not exists(
    select *
    from property
    where pro_type=1 
        and pro_c_id=c_id
)
order by c_id;
```

### 第8关：持有两张信用卡的用户
查询持有两张（含）以上信用卡的用户的名称、身份证号、手机号。

```
select c_name,c_id_card,c_phone
from client
where c_id in (
    select c_id
    from bank_card
    where b_c_id=c_id
    group by b_type
    having count(*)>=2
        and b_type = '信用卡'
)
order by c_id;
```

### 第9关：购买了货币型基金的客户信息
查询购买了货币型(f_type='货币型')基金的用户的名称、电话号、邮箱。

```
select c_name,c_phone,c_mail
from client
where c_id in (
    select c_id
    from fund,property
    where pro_c_id=c_id
        and pro_type = 3
        and f_type = '货币型'
        and pro_pif_id = f_id
)
order by c_id;
```

### 第10关：投资总收益前三名的客户
查询当前总的可用资产收益(被冻结的资产除外)前三名的客户的名称、身份证号及其总收益，按收益降序输出，总收益命名为total_income。不考虑并列排名情形。

```
select 
    c.c_name,
    c.c_id_card,
    SUM(p.pro_income) as total_income
from client c
inner join property p 
    on c.c_id = p.pro_c_id
where 
    p.pro_status = '可用'
group by
    c.c_id, c.c_name, c.c_id_card
order by total_income desc
limit 3;
```

### 第11关：黄姓客户持卡数量
给出黄姓用户的编号、名称、办理的银行卡的数量(没有办卡的卡数量计为0),持卡数量命名为number_of_cards,按办理银行卡数量降序输出,持卡数量相同的,依客户编号排序。

```
select 
    c_id,
    c_name,
    count(b_c_id) number_of_cards
from client
left join bank_card
    on c_id=b_c_id
where c_name like '黄%'
group by c_id,c_name
order by 
    count(b_type) desc,
    c_id asc;
```

### 第12关：客户理财、保险与基金投资总额
综合客户表(client)、资产表(property)、理财产品表(finances_product)、保险表(insurance)和基金表(fund)，列出客户的名称c_name、身份证号c_id_card以及投资总金额(即投资本金，每笔投资金额=商品数量pro_quantity*该产品每份金额pro_income)，注意投资金额按类型需要查询不同的表，投资总金额是客户购买的各类资产pro_type(理财1,保险2,基金3)投资金额的总和，总金额命名为total_amount。查询结果按总金额降序排序。

```
SELECT 
    c.c_name,
    c.c_id_card,
    COALESCE(SUM(p.pro_quantity * fp.p_amount), 0) + 
    COALESCE(SUM(p.pro_quantity * i.i_amount), 0) + 
    COALESCE(SUM(p.pro_quantity * f.f_amount), 0) AS total_amount
FROM client c
LEFT JOIN property p 
    ON c.c_id = p.pro_c_id
LEFT JOIN finances_product fp 
    ON p.pro_type = 1 AND p.pro_pif_id = fp.p_id
LEFT JOIN insurance i 
    ON p.pro_type = 2 AND p.pro_pif_id = i.i_id
LEFT JOIN fund f 
    ON p.pro_type = 3 AND p.pro_pif_id = f.f_id
GROUP BY c.c_id, c.c_name, c.c_id_card
ORDER BY 
    total_amount DESC, 
    c.c_id;
```

### 第13关：客户总资产
综合客户表(client)、资产表(property)、理财产品表(finances_product)、保险表(insurance)、基金表(fund)和投资资产表(property)，列出所有客户的编号、名称和总资产，总资产命名为total_property。总资产为储蓄卡余额，投资总额，投资总收益的和，再扣除信用卡透支的金额(信用卡余额即为透支金额)。客户总资产包括被冻结的资产。

```
SELECT 
    c.c_id,
    c.c_name,
    (COALESCE(bc.储蓄卡金额,0) 
     + COALESCE(pro.投资本金,0) 
     + COALESCE(pro.投资收益,0) 
     - COALESCE(ABS(bx.信用卡余额),0)) AS total_property
FROM client c
LEFT JOIN (
    SELECT 
        b_c_id, 
        SUM(b_balance) AS 储蓄卡金额
    FROM bank_card
    WHERE b_type = '储蓄卡'
    GROUP BY b_c_id
) bc ON bc.b_c_id = c.c_id
LEFT JOIN (
    SELECT 
        b_c_id, 
        SUM(b_balance) AS 信用卡余额
    FROM bank_card
    WHERE b_type = '信用卡'
    GROUP BY b_c_id
) bx ON bx.b_c_id = c.c_id
LEFT JOIN (
    SELECT 
        pro_c_id,
        SUM(CASE pro_type
            WHEN 1 THEN pro_quantity * p_amount
            WHEN 2 THEN pro_quantity * i_amount 
            WHEN 3 THEN pro_quantity * f_amount
        END) AS 投资本金,
        SUM(pro_income) AS 投资收益
    FROM property
    LEFT JOIN finances_product 
        ON pro_type=1 AND pro_pif_id=p_id
    LEFT JOIN insurance 
        ON pro_type=2 AND pro_pif_id=i_id
    LEFT JOIN fund 
        ON pro_type=3 AND pro_pif_id=f_id
    GROUP BY pro_c_id
) pro ON pro.pro_c_id = c.c_id
ORDER BY c.c_id;
```

### 第14关：第N高问题
查询每份保险金额第4高保险产品的编号和保险金额。

在数字序列8000,8000,7000,7000,6000中，两个8000均为第1高，两个7000均为第2高,6000为第3高。

```
select i_id, i_amount
from (
    SELECT 
        i_id,
        i_amount,
        dense_rank() over (order by i_amount desc) as rank_num
    from insurance
) ranked_insurance
where rank_num = 4
order by i_id;
```

### 第15关：基金收益两种方式排名
查询资产表中客户编号，客户基金投资总收益,基金投资总收益的排名(从高到低排名)。总收益相同时名次亦相同(即并列名次)。总收益命名为total_revenue, 名次命名为rank。第一条SQL语句实现全局名次不连续的排名，第二条SQL语句实现全局名次连续的排名。

- 基金总收益排名(名次不连续)

```
select 
    pro_c_id,
    sum(pro_income) total_revenue,
    rank() over(order by sum(pro_income) desc) as 'rank'
from property
where pro_type = 3
group by pro_c_id;
```

- 基金总收益排名(名次连续)

```
select 
    pro_c_id,
    sum(pro_income) total_revenue,
    dense_rank() over(order by sum(pro_income) desc) as 'rank'
from property
where pro_type = 3
group by pro_c_id;
```

### 第16关：持有完全相同基金组合的客户
查询持有相同基金组合的客户对，如编号为A的客户持有的基金，编号为B的客户也持有，反过来，编号为B的客户持有的基金，编号为A的客户也持有，则(A,B)即为持有相同基金组合的二元组，请列出这样的客户对。

为避免过多的重复，如果(1,2)为满足条件的元组，则不必显示(2,1)，即只显示编号小者在前的那一对，这一组客户编号分别命名为c_id1,c_id2。

```
SELECT 
    p1.pro_c_id AS c_id1,
    p2.pro_c_id AS c_id2
FROM (
    SELECT 
        pro_c_id, 
        GROUP_CONCAT(pro_pif_id ORDER BY pro_pif_id) AS funds 
    FROM property 
    WHERE pro_type = 3 
    GROUP BY pro_c_id
) p1
JOIN (
    SELECT 
        pro_c_id, 
        GROUP_CONCAT(pro_pif_id ORDER BY pro_pif_id) AS funds 
    FROM property 
    WHERE pro_type = 3 
    GROUP BY pro_c_id
) p2
ON p1.pro_c_id < p2.pro_c_id 
    AND p1.funds = p2.funds
GROUP BY p1.pro_c_id, p2.pro_c_id;
```

### 第18关：至少有一张信用卡余额超过5000元的客户信用卡总余额
查询至少有一张信用卡余额超过5000元的客户编号，以及该客户持有的信用卡总余额，总余额命名为credit_card_amount。

```
select 
    b_c_id,
    sum(b_balance) credit_card_amount
from bank_card b1
where b_type = '信用卡'
group by b_c_id
having max(b_balance) >=5000
order by b_c_id;
```

### 第19关：以日历表格式显示每日基金购买总金额
以日历表格式列出2022年2月每周每日基金购买总金额，输出格式如下：
| week_of_trading | Monday | Tuesday | Wednesday | Thursday | Friday|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1||||||
|2||||||
|3||||||
|4||||||
|5||||||

```
SELECT 
    ROW_NUMBER() OVER (ORDER BY trading_week) AS week_of_trading,
    SUM(IF(dayofweek = 2, income, null)) AS Monday,
    SUM(IF(dayofweek = 3, income, null)) AS Tuesday,
    SUM(IF(dayofweek = 4, income, null)) AS Wednesday,
    SUM(IF(dayofweek = 5, income, null)) AS Thursday,
    SUM(IF(dayofweek = 6, income, null)) AS Friday
FROM (
    SELECT 
        WEEK(pro_purchase_time, 5) - WEEK('2022-02-01', 5) + 1 AS trading_week,
        DAYOFWEEK(pro_purchase_time) AS dayofweek,
        SUM(pro_quantity * f_amount) AS income
    FROM 
        property
    INNER JOIN fund 
        ON f_id = pro_pif_id
    WHERE 
        pro_type = 3
        AND YEAR(pro_purchase_time) = 2022
        AND MONTH(pro_purchase_time) = 2
        AND DAYOFWEEK(pro_purchase_time) BETWEEN 2 AND 6  -- 过滤周一至周五
    GROUP BY 
        trading_week, dayofweek
) AS daily_data
GROUP BY 
    trading_week
ORDER BY 
    trading_week;
```

## 实训4-MySQL-数据查询(Select)-新增
### 第1关：查询销售总额前三的理财产品
查询销售总额前三的理财产品

```
SELECT
    pyear,
    rk,
    p_id,
    sumamount
FROM (
    SELECT 
        YEAR(pro_purchase_time) AS pyear,
        p_id,
        SUM(IF(pro_type = 1, pro_quantity * p_amount, 0)) AS sumamount,
        RANK() OVER (
            PARTITION BY YEAR(pro_purchase_time) 
            ORDER BY SUM(IF(pro_type = 1, pro_quantity * p_amount, 0)) DESC
        ) rk
    FROM 
        property
    INNER JOIN finances_product 
        ON p_id = pro_pif_id
    WHERE
        YEAR(pro_purchase_time) IN (2010, 2011)
    GROUP BY
        YEAR(pro_purchase_time), p_id
) AS sub
WHERE rk <= 3;
```

### 第2关：投资积极且偏好理财类产品的客户
投资积极且偏好理财类产品的客户

```
SELECT pro_c_id
FROM property
LEFT JOIN finances_product 
    ON pro_pif_id = p_id AND pro_type = 1
LEFT JOIN fund 
    ON pro_pif_id = f_id AND pro_type = 3
GROUP BY pro_c_id
HAVING 
    COUNT(DISTINCT p_id) > COUNT(DISTINCT f_id)
    AND COUNT(DISTINCT p_id) >= 3
ORDER BY pro_c_id;
```

### 第3关：查询购买了所有畅销理财产品的客户
查询购买了所有畅销理财产品的客户

```
SELECT DISTINCT pro_c_id
FROM property p1
WHERE pro_type = 1
    AND NOT EXISTS (
        SELECT 1
        FROM (
            SELECT pro_pif_id
            FROM property
            WHERE pro_type = 1
            GROUP BY pro_pif_id
            HAVING COUNT(DISTINCT pro_c_id) > 2
        ) popular
        WHERE NOT EXISTS (
            SELECT 1
            FROM property p2
            WHERE p2.pro_c_id = p1.pro_c_id
                AND p2.pro_pif_id = popular.pro_pif_id
                AND p2.pro_type = 1
        )
)
ORDER BY pro_c_id;
```

### 第4关：查找相似的理财产品
查找相似的理财产品

```
select
    property.pro_pif_id,
    count(pro_c_id) cc,
    dense_rank() over(
        order by count(pro_c_id) desc
    ) as prank
from property
inner join (    
    select distinct pro_pif_id
    from property
    inner join(    
        select pro_c_id, rk
        from (
            select
                pro_c_id,
                pro_quantity,
                dense_rank() over(
                    order by pro_quantity desc
                ) as rk
            from property
            where pro_pif_id = 14
                and pro_type = 1
        ) as table14
        where rk <=3
    ) as people3
    on people3.pro_c_id = property.pro_c_id
    where pro_type = 1
) as new_pif
on new_pif.pro_pif_id = property.pro_pif_id
where pro_type = 1
    and property.pro_pif_id !=14
group by property.pro_pif_id
order by property.pro_pif_id
;
```

## 实训5-数据查询（Select）-新增2
### 第1关：客户年度从各单位获得的酬劳总额
将客户年度从各单位获得的酬劳进行排序

```
select 
    c_name,
    extract(year from w_time) year, 
    c_id_card, 
    coalesce(sum(if(w_type = 1, w_amount, 0)),0) full_t_amount,
    coalesce(sum(if(w_type = 2, w_amount, 0)),0) part_t_amount
from wage
inner join client 
    on c_id = w_c_id
group by 
    c_id,
    extract(year from w_time),
    c_name,
    c_id_card
order by full_t_amount + part_t_amount desc
;
```

### 第2关：统计各单位不计兼职的薪资总额、月平均薪资、最高薪资、最低薪资、中位薪资
统计各单位不计兼职的薪资总额、月平均薪资、最高薪资、最低薪资、中位薪资

```
WITH 
employee_monthly AS (
    SELECT 
        w.w_c_id,
        w.w_org,
        w.w_amount,
        DATE_FORMAT(w.w_time, '%Y-%m') AS month
    FROM wage w
    INNER JOIN client c ON w.w_c_id = c.c_id  
    WHERE w.w_type = 1
),
employee_avg AS (
    SELECT 
        w_c_id,
        w_org,
        ROUND(AVG(w_amount), 2) AS avg_salary
    FROM employee_monthly
    GROUP BY w_c_id, w_org
),
org_stats AS (
    SELECT 
        w_org,
        SUM(w_amount) AS total_amount,
        COUNT(DISTINCT w_c_id) AS employee_count,
        ROUND(SUM(w_amount) / (COUNT(DISTINCT w_c_id) * COUNT(DISTINCT month)), 2) AS average_wage,
        MAX(w_amount) AS max_wage,
        MIN(w_amount) AS min_wage
    FROM employee_monthly
    GROUP BY w_org
),
median_calculation AS (
    SELECT 
        w_org,
        ROUND(AVG(avg_salary), 2) AS mid_wage
    FROM (
        SELECT 
            w_org,
            avg_salary,
            ROW_NUMBER() OVER (PARTITION BY w_org ORDER BY avg_salary) AS asc_rk,
            ROW_NUMBER() OVER (PARTITION BY w_org ORDER BY avg_salary DESC) AS desc_rk,
            COUNT(*) OVER (PARTITION BY w_org) AS total
        FROM employee_avg
    ) ranked
    WHERE asc_rk BETWEEN total/2 AND total/2 + 1
       OR desc_rk BETWEEN total/2 AND total/2 + 1
    GROUP BY w_org
)

SELECT 
    os.w_org,
    os.total_amount,
    os.average_wage,
    os.max_wage,
    os.min_wage,
    mc.mid_wage
FROM org_stats os
JOIN median_calculation mc ON os.w_org = mc.w_org
ORDER BY os.total_amount DESC;
```

### 第3关：获得兼职总酬劳前三名的客户
获得兼职总酬劳前三名的客户:

```
select 
    c_name,
    c_id_card,
    sum(w_amount) total_salary
from client
join wage
on c_id = w_c_id
where w_type = 2
group by w_c_id
order by sum(w_amount) desc
limit 3
;
```

### 第4关：查找兼职酬劳的前三单位
查找兼职酬劳的前三单位

```
select w_org,sum(w_amount) total_salary
from client
join wage
    on c_id = w_c_id
where w_type = 2
group by w_org
order by sum(w_amount) desc
limit 3
;
```

### 第6关：对身份证号为420108199702144323的客户2023年的酬劳代扣税
对身份证号为C的客户2024年的酬劳代扣税

```
with CTE_wage as(
    select 
        w_c_id,
        sum(w_amount) total_salary,
        greatest(sum(w_amount)-60000,0)*0.2 total_tax
    from wage
    join  client
        on c_id = w_c_id
    where c_id_card = '420108199702144323'
        and year(w_time) = 2023
    group by w_c_id
)
update wage
join CTE_wage
    on CTE_wage.w_c_id = wage.w_c_id
set w_amount = w_amount - total_tax*w_amount/total_salary,
    w_tax = if(total_tax>0 , 'Y' , 'N')
where year(w_time) = 2023
;
```

## 实训6-MySQL-数据的插入、修改与删除(Insert,Update,Delete)
### 第1关：插入多条完整的客户信息
用insert语句向客户表(client)插入任务要求的3条数据:

```
insert into client
values
(1,'林惠雯','960323053@qq.com',
    '411014196712130323','15609032348','Mop5UPk1'),
(2,'吴婉瑜','1613230826@gmail.com',
    '420152196802131323','17605132307','QUTPhxgVNlXtMXN'),
(3,'蔡贞仪','252323341@foxmail.com',
    '17763232321','160347199065222323Bwe3gyhEErJ7');
```

### 第2关：插入不完整的客户信息
将这名客户的信息插入到客户表(client)

```
insert intoclient
values (33,'蔡依婷'nul1,'350972199204227621','18820762130','MKWEuc1sc6');
```

### 第3关：批量插入数据
已知表new client保存了一批新客户信息，该表与c1ient表结构完全相同。
将new client表的全部客户信息插入到客户表(client):

```
insert into client
select *
from new client;
```

### 第4关：删除没有银行卡的客户信息
请用一条SQL语句删除client表中没有银行卡的客户信息:

```
delete from client
where c_id not in(
    select b_c id
    from bank card
);
```

### 第5关：冻结客户资产
请用一条update语句将手机号码为“13686431238”的这位客户的投资资产(理财、保险与基金)的状态置为“冻结”。

```
update property
set pro_status ='冻结
where pro c id = (
    select c id
    from client
    where c phone =:13686431238
);
```

### 第6关：连接更新
在金融应用场景数据库中，已在表property(资产表)中添加了客户身份证列，列名为pro id card，类型为char(18)，该列目前全部留空(nu11)。

请用一条update语句，根据client表中提供的身份证号(c_id_card)，填写property表中对应的身份证号信息(pro id card)。

```
update property
join client
    on c id = pro_c id
set pro id card = c id card;
```

## 实训7-MySQL-视图
### 第1关：创建所有保险资产的详细记录视图
创建包含所有保险资产记录的详细信息的视图v_insurance_detail，包括购买客户的名称、客户的身份证号、保险名称、保障项目、商品状态、商品数量、保险金额、保险年限、商品收益和购买时间。

```
create view v_insurance_detail
as
select 
    c_name,
    c_id_card,
    i_name,
    i_project,
    pro_status,
    pro_quantity,
    i_amount,
    i_year,
    pro_income,
    pro_purchase_time
from property
join client
    on c_id = pro_c_id
join insurance
    on i_id = pro_pif_id
where pro_type = 2;
```

### 第2关：基于视图的查询
基于上一关创建的视图v_insurance_detail进行分组统计查询，列出每位客户的姓名，身份证号，保险投资总额(insurance_total_amount)和保险投资总收益(insurance_total_revenue),结果依保险投资总额降序排列。

```
select
    c_name,
    c_id_card,
    sum(i_amount*pro_quantity) insurance_total_amount,
    sum(pro_income) insurance_total_revenue
from v_insurance_detail
group by c_name,c_id_card
order by sum(i_amount*pro_quantity) desc;
```

## 实训8-MySQL - 存储过程与事务
### 第1关：使用流程控制语句的存储过程
创建存储过程`sp_fibonacci(in m int)`，向表fibonacci插入斐波拉契数列的前m项，及其对应的斐波拉契数。fibonacci表初始值为一张空表。请保证你的存储过程可以多次运行而不出错。

```
drop procedure if exists sp_fibonacci;
delimiter $$
create procedure sp_fibonacci(in m int)
begin

declare num1 int;
declare num2 int;
declare num3 int;
declare i int;
set num1 = 0;
set num2 = 1;
set i = 0;
while i < m DO
    if i = 0 then
        insert into fibonacci(n,fibn) values(i,num1);
    end if;
    if i = 1 then
        insert into fibonacci(n,fibn) values(i,num2);
    end if;
    if i >= 2 then
        set num3 = num1 + num2;
        set num1 = num2;
        set num2 = num3;
        insert into fibonacci(n,fibn) values(i,num3);
    end if;
 
    set i = i+1;
END WHILE;
end $$

delimiter ;
```

### 第2关：使用游标的存储过程
编写一存储过程，自动安排某个连续期间的大夜班的值班表:

```
delimiter $$
create procedure sp_night_shift_arrange(in start_date date, in end_date date)

begin
    declare no_doctor boolean default false;
    declare no_nurse boolean default false;
    declare no_data boolean default false;
    declare d date;
    declare doctor_name char(30);
    declare doctor_type int;
    declare nurse1_name char(30);
    declare nurse2_name char(30);
    declare director_found boolean default false;
    declare director_name char(30);
    declare cur_doctor cursor for select e_name,e_type from employee where (e_type) = 1 or (e_type = 2) order by e_id;
    declare cur_nurse cursor for select e_name from employee where e_type = 3 order by e_id;
    declare continue HANDLER for NOT FOUND set no_data = true;
    open cur_doctor;
    open cur_nurse;
    
set d = start_date;
while (d <= end_date) do
if director_found and (dayname(d) = 'Monday') then
set doctor_name = director_name;
set director_found = false;
else
fetch cur_doctor into doctor_name,doctor_type;
set no_doctor = no_data;
if no_doctor then
set no_data = false;
close cur_doctor;
open cur_doctor;
fetch cur_doctor into doctor_name,doctor_type;
set no_doctor=no_data;
end if;
 
if dayname(d) in ('Saturday','Sunday') and (doctor_type = 1) then
    set director_found = true;
    set director_name = doctor_name;
    if no_doctor then
    set no_data = false;
    close cur_doctor;
    open cur_doctor;
    fetch cur_doctor into doctor_name,doctor_type;
    set no_doctor = no_data;
    else
    fetch cur_doctor into doctor_name,doctor_type;
    set no_doctor = no_data;
        if no_doctor then
        set no_data = false;
        close cur_doctor;
        open cur_doctor;
        fetch cur_doctor into doctor_name,doctor_type;
        set no_doctor = no_data;
        end if;
    end if;
end if;
end if;
 
fetch cur_nurse into nurse1_name;
set no_nurse = no_data;
if no_nurse then
    set no_data = false;
    close cur_nurse;
    open cur_nurse;
    fetch cur_nurse into nurse1_name;
end if;
 
fetch cur_nurse into nurse2_name;
set no_nurse = no_data;
if no_nurse then
    set no_data = false;
    close cur_nurse;
    open cur_nurse;
    fetch cur_nurse into nurse2_name;
end if;
 
insert into night_shift_schedule values(d,doctor_name,nurse1_name,nurse2_name);
 
set d = adddate(d,interval 1 day);
 
end while;

end$$

delimiter ;
```

### 第3关：使用事务的存储过程
在金融应用场景数据库中，编程实现一个转账操作的存储过程sp_transfer_balance，实现从一个帐户向另一个帐户转账。

```
delimiter $$
create procedure sp_transfer(
	IN applicant_id int,      
    IN source_card_id char(30),
	IN receiver_id int, 
    IN dest_card_id char(30),
	IN	amount numeric(10,2),
	OUT return_code int)
BEGIN

    start transaction;
set return_code = 0;
if exists (
    select * 
    from bank_card
    where b_number = source_card_id 
        and b_c_id = applicant_id 
        and b_type = '储蓄卡'
        and b_balance >= amount
    ) 
    and exists (
        select * 
        from bank_card
        where b_number = dest_card_id 
            and b_c_id = receiver_id
    )
then
    update bank_card 
    set b_balance =
        if(b_type = '信用卡', b_balance - amount, b_balance + amount)
    where b_number = dest_card_id;

    update bank_card
    set b_balance = 
        b_balance - amount where b_number = 
        source_card_id;
        
    set return_code = 1;
end if;
commit;

END$$

delimiter ;
```

## 实训9-MySQL-触发器
### 第1关：为投资表property实现业务约束规则-根据投资类别分别引用不同表的主码
```
delimiter $$
CREATE TRIGGER before_property_inserted 
BEFORE INSERT 
ON property
FOR EACH ROW 
BEGIN
    IF (NEW.pro_type NOT IN (1,2,3)) THEN
        SET @msg = CONCAT('type ', NEW.pro_type, ' is illegal!');
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @msg;
    END IF;
    IF (NEW.pro_type = 1) AND (SELECT COUNT(*) FROM finances_product WHERE p_id = NEW.pro_pif_id) = 0 THEN
        SET @msg = CONCAT('finances product #', NEW.pro_pif_id, ' not found!');
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @msg;
    END IF;
    IF (NEW.pro_type = 2) AND (SELECT COUNT(*) FROM insurance WHERE i_id = NEW.pro_pif_id) = 0 THEN
        SET @msg = CONCAT('insurance #', NEW.pro_pif_id, ' not found!');
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @msg;
    END IF;
    IF (NEW.pro_type = 3) AND (SELECT COUNT(*) FROM fund WHERE f_id = NEW.pro_pif_id) = 0 THEN
        SET @msg = CONCAT('fund #', NEW.pro_pif_id, ' not found!');
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = @msg;
    END IF;
END$$
 
delimiter ;
```

## 实训10-MySQL-用户自定义函数
### 第1关：创建函数并在语句中使用它
用create function语句创建符合以下要求的函数：
- 依据客户编号计算该客户所有储蓄卡的存款总额。
- 函数名为：get_Records。函数的参数名可以自己命名:

```
DELIMITER $$
CREATE FUNCTION get_deposit(client_id INT)
RETURNS DECIMAL(10,2)  -- 使用DECIMAL精确存储金额
DETERMINISTIC  -- 声明为确定性函数
BEGIN
    DECLARE total DECIMAL(10,2) DEFAULT 0.00;
    DECLARE cur_balance DECIMAL(10,2); 
    DECLARE done BOOLEAN DEFAULT FALSE; 
    
    DECLARE cur CURSOR FOR 
        SELECT b_balance 
        FROM bank_card 
        WHERE b_c_id = client_id AND b_type = '储蓄卡';
    
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;
    
    OPEN cur;
    
    read_loop: LOOP
        FETCH cur INTO cur_balance; 
        IF done THEN
            LEAVE read_loop; 
        END IF;
        SET total = total + cur_balance; 
    END LOOP;
    
    CLOSE cur;
    RETURN total; 
END
$$
DELIMITER ;
```

应用该函数查询存款总额在100万以上的客户身份证号，姓名和存储总额(total_deposit)，结果依存款总额从高到代排序。

```
select distinct 
    c_id_card,
    c_name,
    get_deposit(c_id) total_deposit
from client,bank_card
where c_id = b_c_id
    and b_type = '储蓄卡'
    and get_deposit(c_id) >= 1000000
order by get_deposit(c_id) desc;
```

## 实训11-MySQL-安全性控制
### 第1关：用户和权限
- 创建用户tom和jerry

```
CREATE USER 'tom'@'%' IDENTIFIED BY '123456';
CREATE USER 'jerry'@'%' IDENTIFIED BY '123456';
```

- 授予tom权限

```
GRANT SELECT(c_name,c_mail,c_phone)
ON table client
TO 'tom'@'%' 
WITH GRANT OPTION;
```

- 授予jerry权限

```
GRANT UPDATE(b_balance) 
ON bank_card 
TO 'jerry'@'%';
```

- 收回Cindy权限

```
REVOKE SELECT ON bank_card 
FROM 'Cindy'@'%';
```
### 第2关：用户、角色与权限
- 创建角色client_manager和fund_manager；

```
create role client_manager,fund_manager;
```
- 授予client_manager对client表拥有select,insert,update的权限；

```
grant select,insert,update
on table client 
to client_manager;
```
- 授予client_manager对bank_card表拥有查询除银行卡余额外的select权限；

```
grant select(b_number,b_type,b_c_id)
on table bank_card
to client_manager;
```
- 授予fund_manager对fund表的select,insert,update权限；

```
grant select,insert,update
on table fund 
to fund_manager;
```
- 将client_manager的权限授予用户tom和jerry；

```
grant client_manager
to tom,jerry;
```
- 将fund_manager权限授予用户Cindy.

```
grant fund_manager
to Cindy;
```

## 实训14-MySQL-数据库设计与实现
### 第1关：从概念模型到MySQL实现
```
DROP DATABASE IF EXISTS flight_booking;
CREATE DATABASE flight_booking;
USE flight_booking;
```
```
DROP TABLE IF EXISTS user;
CREATE TABLE user(
    user_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '用户编号',
    firstname VARCHAR(50) NOT NULL COMMENT '名字',
    lastname VARCHAR(50) NOT NULL COMMENT '姓氏',
    dob DATE NOT NULL COMMENT '生日',
    sex CHAR(1) NOT NULL COMMENT '性别',
    email VARCHAR(50) COMMENT '邮箱',
    phone VARCHAR(30) COMMENT '联系电话',
    username VARCHAR(20) NOT NULL UNIQUE COMMENT '用户名',
    password CHAR(32) NOT NULL COMMENT '密码',
    admin_tag TINYINT NOT NULL DEFAULT 0 COMMENT '管理员标志'
)COMMENT '用户表';
```
```
DROP TABLE IF EXISTS passenger;
CREATE TABLE passenger(
    passenger_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '旅客编号',
    id CHAR(18) NOT NULL UNIQUE COMMENT '证件号码',
    firstname VARCHAR(50) NOT NULL COMMENT '名字',
    lastname VARCHAR(50) NOT NULL COMMENT '姓氏',
    mail VARCHAR(50) COMMENT '邮箱',
    phone VARCHAR(20) NOT NULL COMMENT '电话',
    sex CHAR(1) NOT NULL COMMENT '性别',
    dob DATE COMMENT '生日'
)COMMENT '旅客表';
```
```
DROP TABLE IF EXISTS airport;
CREATE TABLE airport(
    airport_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '机场编号',
    iata CHAR(3) NOT NULL UNIQUE COMMENT '国际民航组织编码',
    icao CHAR(4) NOT NULL UNIQUE COMMENT '国际航运协会编码',
    name VARCHAR(50) NOT NULL COMMENT '机场名称',
    city VARCHAR(50) COMMENT '所在城市',
    country VARCHAR(50) COMMENT '所在国家',
    latitude DECIMAL(11,8) COMMENT '纬度',
    longitude DECIMAL(11,8) COMMENT '经度',
    index (name)
)COMMENT '机场表';
```
```
DROP TABLE IF EXISTS airline;
CREATE TABLE airline(
    airline_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '航空公司编号',
    name VARCHAR(30) NOT NULL COMMENT '航空公司名称',
    iata CHAR(2) NOT NULL UNIQUE COMMENT '国际民航组织编码',
    airport_id INT NOT NULL COMMENT '母港',
    FOREIGN KEY (airport_id) REFERENCES airport(airport_id)
)COMMENT '航空公司表';
```
```
DROP TABLE IF EXISTS airplane;
CREATE TABLE airplane(
    airplane_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '飞机编号',
    type VARCHAR(50) NOT NULL COMMENT '机型',
    capacity SMALLINT NOT NULL COMMENT '座位',
    identifier VARCHAR(50) NOT NULL COMMENT '标识',
    airline_id INT NOT NULL COMMENT '航空公司编号',
    constraint FOREIGN KEY (airline_id) REFERENCES airline(airline_id)
)COMMENT '民航飞机表';
```
```
DROP TABLE IF EXISTS flightschedule;
CREATE TABLE flightschedule(
    flight_no CHAR(8) PRIMARY KEY COMMENT '航班号',
    departure TIME NOT NULL COMMENT '起飞时间',
    arrival TIME NOT NULL COMMENT '到达时间',
    duration SMALLINT NOT NULL COMMENT '飞行时长',
    monday TINYINT DEFAULT 0 COMMENT '周一',
    tuesday TINYINT DEFAULT 0 COMMENT '周二',
    wednesday TINYINT DEFAULT 0 COMMENT '周三',
    thursday TINYINT DEFAULT 0 COMMENT '周四',
    friday TINYINT DEFAULT 0 COMMENT '周五',
    saturday TINYINT DEFAULT 0 COMMENT '周六',
    sunday TINYINT DEFAULT 0 COMMENT '周日',
    `from` INT NOT NULL COMMENT '起飞机场编号',
    `to` INT NOT NULL COMMENT '到达机场编号',
    airline_id INT NOT NULL COMMENT '航空公司编号',
    constraint FOREIGN KEY (`from`) REFERENCES airport(airport_id),
    constraint FOREIGN KEY (`to`) REFERENCES airport(airport_id),
    constraint FOREIGN KEY (airline_id) REFERENCES airline(airline_id)
)COMMENT '航班常规调度表';
```
```
DROP TABLE IF EXISTS flight;
CREATE TABLE flight(
    flight_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '飞行编号',
    departure DATETIME NOT NULL COMMENT '起飞时间',
    arrival DATETIME NOT NULL COMMENT '到达时间',
    duration SMALLINT NOT NULL COMMENT '飞行时长',
    airline_id INT NOT NULL COMMENT '航空公司编号',
    airplane_id INT NOT NULL COMMENT '飞机编号',
    `from` INT NOT NULL COMMENT '起飞机场编号',
    `to` INT NOT NULL COMMENT '到达机场编号',
    flight_no CHAR(8) NOT NULL COMMENT '航班号',
    constraint FOREIGN KEY (airline_id) REFERENCES airline(airline_id),
    constraint FOREIGN KEY (airplane_id) REFERENCES airplane(airplane_id),
    constraint FOREIGN KEY (`from`) REFERENCES airport(airport_id),
    constraint FOREIGN KEY (`to`) REFERENCES airport(airport_id),
    constraint FOREIGN KEY (flight_no) REFERENCES flightschedule(flight_no)
)COMMENT '航班表';
```
```
DROP TABLE IF EXISTS ticket;
CREATE TABLE ticket(
    ticket_id INT AUTO_INCREMENT PRIMARY KEY COMMENT '票号',
    seat CHAR(4) COMMENT '座位号',
    price DECIMAL(10,2) NOT NULL COMMENT '价格',
    flight_id INT NOT NULL COMMENT '飞行编号',
    user_id INT NOT NULL COMMENT '用户编号',
    passenger_id INT NOT NULL COMMENT '旅客编号',
    constraint FOREIGN KEY (flight_id) REFERENCES flight(flight_id),
    constraint FOREIGN KEY (user_id) REFERENCES user(user_id),
    constraint FOREIGN KEY (passenger_id) REFERENCES passenger(passenger_id)
)COMMENT '机票';
```

### 第2关：从需求分析到逻辑模型
请给出ER图文件存放的URL:
(https://github.com/2980454492/mysql/blob/main/ersolution.jpg)

以下给出关系模式：
```
电影movie(movie_ID, title, type, runtime, release_date, director, starring), 
主码:(movie_ID)
```
```
顾客customer(c_ID, name, phone), 
主码:(c_ID)
```
```
放映厅hall(hall_ID, mode, capacity, location), 
主码:(hall_ID)
```
```
排场schedule(schedule_ID, date, time, price, number, hall_ID, movie_ID), 
主码:(schedule_ID)，
外码：(hall_ID) 参照放映厅(hall),(movie_ID) 参照电影(movie)
```
```
电影票ticket(ticket_ID, seat_num, c_ID, schedule_ID), 
主码:(ticket_ID)，
外码：(c_ID) 参照顾客(customer),(schedule_ID) 参照排场(schedule)
```
### 第3关：建模工具的使用
请将利用MySQL Workbench软件的Modeling工具，经forward engineering 导出的创建schema的SQL语句完整粘到此处

```
SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0; 
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0; 
SET @OLD_SQL_MODE=@@SQL_MODE, 
SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
```
```
CREATE SCHEMA IF NOT EXISTS rbac DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci ; 
USE rbac ;
```
```
CREATE TABLE IF NOT EXISTS rbac . aprole (
RoleNo INT NOT NULL COMMENT '角色编号', 
RoleName CHAR(20) NOT NULL COMMENT '角色名', 
Comment VARCHAR(50) NULL DEFAULT NULL COMMENT '角色描述', 
Status SMALLINT NULL DEFAULT NULL COMMENT '角色状态', 
PRIMARY KEY ( RoleNo )) 
ENGINE = InnoDB 
DEFAULT CHARACTER SET = utf8mb4 
COLLATE = utf8mb4_0900_ai_ci 
COMMENT = '角色表';
```
```
CREATE TABLE IF NOT EXISTS rbac . apuser(
    UserID CHAR(8) NOT NULL COMMENT '用户工号',
    UserName CHAR(8) NULL DEFAULT NULL COMMENT '用户姓名', 
    Comment VARCHAR(50) NULL DEFAULT NULL COMMENT '用户描述', 
    PassWord CHAR(32) NULL DEFAULT NULL COMMENT '口令', 
    Status SMALLINT NULL DEFAULT NULL COMMENT '状态',
    PRIMARY KEY ( UserID ), 
    UNIQUE INDEX ind_username ( UserName ASC) VISIBLE) 
    ENGINE = InnoDB 
    DEFAULT CHARACTER SET = utf8mb4
    COLLATE = utf8mb4_0900_ai_ci 
    COMMENT = '用户表';
```
```
CREATE TABLE IF NOT EXISTS rbac . apgroup (
    UserID CHAR(8) NOT NULL COMMENT '用户编号', 
    RoleNo INT NOT NULL COMMENT '角色编号', 
    PRIMARY KEY ( UserID , RoleNo ), 
    INDEX FK_apGroup_apRole ( RoleNo ASC) VISIBLE, 
    CONSTRAINT FK_apGroup_apRole FOREIGN KEY ( RoleNo ) REFERENCES rbac . aprole ( RoleNo ),
    CONSTRAINT FK_apGroup_apUser FOREIGN KEY ( UserID ) REFERENCES rbac . apuser ( UserID ))
    ENGINE = InnoDB 
    DEFAULT CHARACTER SET = utf8mb4 
    COLLATE = utf8mb4_0900_ai_ci 
    COMMENT = '角色分配表';
```
```
CREATE TABLE IF NOT EXISTS rbac . apmodule (
    ModNo BIGINT NOT NULL COMMENT '模块编号', 
    ModID CHAR(10) NULL DEFAULT NULL COMMENT '系统或模块的代码', 
    ModName CHAR(20) NULL DEFAULT NULL COMMENT '系统或模块的名称', PRIMARY KEY ( ModNo ))
    ENGINE = InnoDB 
    DEFAULT CHARACTER SET = utf8mb4 
    COLLATE = utf8mb4_0900_ai_ci 
    COMMENT = '功能模块登记表';
```
```
CREATE TABLE IF NOT EXISTS rbac . apright (
    RoleNo INT NOT NULL COMMENT '角色编号', 
    ModNo BIGINT NOT NULL COMMENT '模块编号', 
    PRIMARY KEY ( RoleNo , ModNo ), 
    INDEX FK_apRight_apModule ( ModNo ASC) VISIBLE,
    CONSTRAINT FK_apRight_apModule 
    FOREIGN KEY ( ModNo ) 
    REFERENCES rbac . apmodule ( ModNo ), 
    CONSTRAINT FK_apRight_apRole
    FOREIGN KEY ( RoleNo ) 
    REFERENCES rbac . aprole ( RoleNo )
)ENGINE = InnoDB 
DEFAULT CHARACTER SET = utf8mb4 
COLLATE = utf8mb4_0900_ai_ci 
COMMENT = '角色权限表';
```
```
SET SQL_MODE=@OLD_SQL_MODE; 
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS; 
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
```

## 实训15-MySQL-数据库应用开发(JAVA篇)
### 第1关：JDBC体系结构和简单的查询
```
import java.sql.*;

public class Client {
    public static void main(String[] args) {
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");
            String URL = "jdbc:mysql://127.0.0.1:3306/finance?useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=UTC";
            String USER = "root";
            String PASS = "123123";
            
            connection = DriverManager.getConnection(URL, USER, PASS);
            statement = connection.createStatement();
            
            String sql = "SELECT c_name, c_mail, c_phone FROM client WHERE c_mail IS NOT NULL";
            resultSet = statement.executeQuery(sql);
            
            // 按题目要求输出标题（1个制表符 + 4个制表符）
            System.out.println("姓名\t邮箱\t\t\t\t电话");
            
            while (resultSet.next()) {
                String name = resultSet.getString("c_name");
                String mail = resultSet.getString("c_mail");
                String phone = resultSet.getString("c_phone");
                // 按题目要求输出数据（1个制表符 + 2个制表符）
                System.out.println(name + "\t" + mail + "\t\t" + phone);
            }

        } catch (ClassNotFoundException e) {
            System.out.println("Sorry,can`t find the JDBC Driver!"); 
            e.printStackTrace();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            try {
                if (resultSet != null) resultSet.close();
                if (statement != null) statement.close();
                if (connection != null) connection.close();
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}
```

### 第2关：用户登录
```
import java.sql.*;
import java.util.Scanner;

public class Login {
    public static void main(String[] args) {
        Connection connection = null;
        //申明下文中的resultSet, statement
        ResultSet resultSet = null;
        PreparedStatement statement = null;

        Scanner input = new Scanner(System.in);

        System.out.print("请输入用户名：");
        String loginName = input.nextLine();
        System.out.print("请输入密码：");
        String loginPass = input.nextLine();

        try {
            Class.forName("com.mysql.cj.jdbc.Driver");

            String userName = "root";
            String passWord = "123123";
            String url = "jdbc:mysql://127.0.0.1:3306/finance?useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=UTC";
            connection = DriverManager.getConnection(url, userName, passWord);
            // 补充实现代码:
            String sql = "SELECT c_id FROM client WHERE c_mail = ? AND c_password = ?";
            statement = connection.prepareStatement(sql);
            statement.setString(1, loginName);
            statement.setString(2, loginPass);
            
            resultSet = statement.executeQuery();
            
            if (resultSet.next()) {
                System.out.println("登录成功。");
            } else {
                System.out.println("用户名或密码错误！");
            }

         } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
                if (statement != null) {
                    statement.close();
                }

                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}
```

### 第3关：添加新客户
```
import java.sql.*;
import java.util.Scanner;

public class AddClient {
    static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
    static final String DB_URL = "jdbc:mysql://127.0.0.1:3306/finance?allowPublicKeyRetrieval=true&useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=UTC";
    static final String USER = "root";
    static final String PASS = "123123";
    /**
     * 向Client表中插入数据
     *
     * @param connection 数据库连接对象
     * @param c_id 客户编号
     * @param c_name 客户名称
     * @param c_mail 客户邮箱
     * @param c_id_card 客户身份证
     * @param c_phone 客户手机号
     * @param c_password 客户登录密码
     */
    public static int insertClient(Connection connection,
                                   int c_id, String c_name, String c_mail,
                                   String c_id_card, String c_phone, 
                                   String c_password){

        String sql = "INSERT INTO client(c_id, c_name, c_mail, c_id_card, c_phone, c_password) " +
                 "VALUES (?, ?, ?, ?, ?, ?)";
    
        PreparedStatement pstmt = null;
        try {
            // 创建PreparedStatement对象
            pstmt = connection.prepareStatement(sql);
            
            // 设置参数值
            pstmt.setInt(1, c_id);
            pstmt.setString(2, c_name);
            pstmt.setString(3, c_mail);
            pstmt.setString(4, c_id_card);
            pstmt.setString(5, c_phone);
            pstmt.setString(6, c_password);
            
            // 执行插入操作并返回影响的行数
            return pstmt.executeUpdate();
            
        } catch (SQLException e) {
            // 处理可能的SQL异常（如唯一约束冲突）
            e.printStackTrace();
            return 0; // 返回0表示插入失败
        } finally {
            // 关闭PreparedStatement
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }


    }

    // 不要修改main() 
    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(System.in);
        Class.forName(JDBC_DRIVER);

        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

        while(sc.hasNext())
        {
            String input = sc.nextLine();
            if(input.equals(""))
                break;

            String[]commands = input.split(" ");
            if(commands.length ==0)
                break;
            int id = Integer.parseInt(commands[0]);
            String name = commands[1];
            String mail = commands[2];
            String idCard = commands[3];
            String phone = commands[4];
            String password = commands[5];

            insertClient(connection, id, name, mail, idCard, phone, password);
        }
    }

}
```

### 第4关：银行卡销户
```
import java.sql.*;
import java.util.Scanner;

public class RemoveCard {
    static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
    static final String DB_URL = "jdbc:mysql://127.0.0.1:3306/finance?allowPublicKeyRetrieval=true&useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=UTC";
    static final String USER = "root";
    static final String PASS = "123123";
    /**
     * 删除bank_card表中数据
     *
     * @param connection 数据库连接对象
     * @param b_c_id 客户编号
     * @param c_number 银行卡号
     */
    public static int removeBankCard(Connection connection,
                                   int b_c_id, String b_number){

        // 定义删除SQL语句
        String sql = "DELETE FROM bank_card WHERE b_c_id = ? AND b_number = ?";
        
        PreparedStatement pstmt = null;
        try {
            // 创建PreparedStatement对象
            pstmt = connection.prepareStatement(sql);
            
            // 设置参数值
            pstmt.setInt(1, b_c_id);
            pstmt.setString(2, b_number);
            
            // 执行删除操作并返回影响的行数
            return pstmt.executeUpdate();
            
        } catch (SQLException e) {
            // 处理可能的SQL异常
            e.printStackTrace();
            return 0; // 返回0表示删除失败
        } finally {
            // 关闭PreparedStatement
            try {
                if (pstmt != null) {
                    pstmt.close();
                }
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }


    }

    // 不要修改main() 
    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(System.in);
        Class.forName(JDBC_DRIVER);

        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

        while(sc.hasNext())
        {
            String input = sc.nextLine();
            if(input.equals(""))
                break;

            String[]commands = input.split(" ");
            if(commands.length ==0)
                break;
            int id = Integer.parseInt(commands[0]);
            String carNumber = commands[1];
            
            int n = removeBankCard(connection, id, carNumber);
            if (n > 0) {
               System.out.println("已销卡数：" + n);
            } else {
               System.out.println("销户失败，请检查客户编号或银行卡号！" );
            }
        }
    }

}
```

### 第5关：客户修改密码
```
import java.sql.*;
import java.util.Scanner;

public class ChangePass {
    static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
    static final String DB_URL = "jdbc:mysql://127.0.0.1:3306/finance?allowPublicKeyRetrieval=true&useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=UTC";
    static final String USER = "root";
    static final String PASS = "123123";
    
    /**
     * 修改客户密码
     *
     * @param connection 数据库连接对象
     * @param mail 客户邮箱,也是登录名
     * @param password 客户登录密码
     * @param newPass  新密码
     * @return
     *   1 - 密码修改成功
     *   2 - 用户不存在
     *   3 - 密码不正确
     *  -1 - 程序异常(如没能连接到数据库等）
     */
    public static int passwd(Connection connection,
                             String mail,
                             String password, 
                             String newPass) {
        PreparedStatement checkStmt = null;
        PreparedStatement updateStmt = null;
        ResultSet rs = null;
        
        try {
            // 第一步：验证用户是否存在且密码正确
            String checkSql = "SELECT c_id FROM client WHERE c_mail = ? AND c_password = ?";
            checkStmt = connection.prepareStatement(checkSql);
            checkStmt.setString(1, mail);
            checkStmt.setString(2, password);
            
            rs = checkStmt.executeQuery();
            
            if (!rs.next()) {
                // 用户不存在或密码不正确
                // 进一步检查用户是否存在
                String existSql = "SELECT c_id FROM client WHERE c_mail = ?";
                PreparedStatement existStmt = connection.prepareStatement(existSql);
                existStmt.setString(1, mail);
                ResultSet existRs = existStmt.executeQuery();
                
                if (existRs.next()) {
                    // 用户存在但密码错误
                    existRs.close();
                    existStmt.close();
                    return 3;
                } else {
                    // 用户不存在
                    existRs.close();
                    existStmt.close();
                    return 2;
                }
            }
            
            // 第二步：更新密码
            String updateSql = "UPDATE client SET c_password = ? WHERE c_mail = ?";
            updateStmt = connection.prepareStatement(updateSql);
            updateStmt.setString(1, newPass);
            updateStmt.setString(2, mail);
            
            int rowsUpdated = updateStmt.executeUpdate();
            
            if (rowsUpdated > 0) {
                return 1; // 密码修改成功
            } else {
                return -1; // 更新失败，程序异常
            }
            
        } catch (SQLException e) {
            e.printStackTrace();
            return -1; // 程序异常
        } finally {
            // 关闭资源
            try {
                if (rs != null) rs.close();
                if (checkStmt != null) checkStmt.close();
                if (updateStmt != null) updateStmt.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    // 不要修改main() 
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        Class.forName(JDBC_DRIVER);
        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

        while(sc.hasNext()) {
            String input = sc.nextLine();
            if(input.equals("")) break;

            String[] commands = input.split(" ");
            if(commands.length == 0) break;
            
            String email = commands[0];
            String pass = commands[1];
            String pwd1 = commands[2];
            String pwd2 = commands[3];
            
            if (pwd1.equals(pwd2)) {
                int n = passwd(connection, email, pass, pwd1);  
                System.out.println("return: " + n);
            } else {
                System.out.println("两次输入的密码不一样!");
            }
        }
    }
}
```

### 第6关：事务与转账操作
```
import java.sql.*;
import java.util.Scanner;

public class Transfer {
    static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";
    static final String DB_URL = "jdbc:mysql://127.0.0.1:3306/finance?allowPublicKeyRetrieval=true&useUnicode=true&characterEncoding=UTF8&useSSL=false&serverTimezone=UTC";
    static final String USER = "root";
    static final String PASS = "123123";
    
    /**
     * 转账操作
     *
     * @param connection 数据库连接对象
     * @param sourceCard 转出账号
     * @param destCard 转入账号
     * @param amount  转账金额
     * @return boolean
     *   true  - 转账成功
     *   false - 转账失败
     */
    public static boolean transferBalance(Connection connection,
                                         String sourceCard,
                                         String destCard, 
                                         double amount) {
        // 开启事务
        try {
            connection.setAutoCommit(false);
        } catch (SQLException e) {
            e.printStackTrace();
            return false;
        }

        PreparedStatement sourceStmt = null;
        PreparedStatement destStmt = null;
        ResultSet sourceRs = null;
        ResultSet destRs = null;
        
        try {
            // 1. 检查转出账户是否存在且是储蓄卡
            String sourceSql = "SELECT b_type, b_balance FROM bank_card WHERE b_number = ? FOR UPDATE";
            sourceStmt = connection.prepareStatement(sourceSql);
            sourceStmt.setString(1, sourceCard);
            sourceRs = sourceStmt.executeQuery();
            
            if (!sourceRs.next()) {
                return false; // 转出账号不存在
            }
            
            String sourceType = sourceRs.getString("b_type");
            double sourceBalance = sourceRs.getDouble("b_balance");
            
            // 检查转出账号是否是信用卡
            if ("信用卡".equals(sourceType)) {
                return false; // 转出账号是信用卡
            }
            
            // 检查转出账号余额是否充足
            if (sourceBalance < amount) {
                return false; // 余额不足
            }
            
            // 2. 检查转入账户是否存在并获取类型
            String destSql = "SELECT b_type, b_balance FROM bank_card WHERE b_number = ? FOR UPDATE";
            destStmt = connection.prepareStatement(destSql);
            destStmt.setString(1, destCard);
            destRs = destStmt.executeQuery();
            
            if (!destRs.next()) {
                return false; // 转入账号不存在
            }
            String destType = destRs.getString("b_type");
            
            // 3. 执行转账操作
            // 更新转出账户余额
            String updateSourceSql = "UPDATE bank_card SET b_balance = b_balance - ? WHERE b_number = ?";
            try (PreparedStatement updateSource = connection.prepareStatement(updateSourceSql)) {
                updateSource.setDouble(1, amount);
                updateSource.setString(2, sourceCard);
                int rowsUpdated = updateSource.executeUpdate();
                if (rowsUpdated != 1) {
                    connection.rollback();
                    return false;
                }
            }
            
            // 更新转入账户余额：根据类型决定加减
            String updateDestSql;
            if ("信用卡".equals(destType)) {
                // 信用卡：减少余额（减少透支金额）
                updateDestSql = "UPDATE bank_card SET b_balance = b_balance - ? WHERE b_number = ?";
            } else {
                // 储蓄卡：增加余额
                updateDestSql = "UPDATE bank_card SET b_balance = b_balance + ? WHERE b_number = ?";
            }
            
            try (PreparedStatement updateDest = connection.prepareStatement(updateDestSql)) {
                updateDest.setDouble(1, amount);
                updateDest.setString(2, destCard);
                int rowsUpdated = updateDest.executeUpdate();
                if (rowsUpdated != 1) {
                    connection.rollback();
                    return false;
                }
            }
            
            // 提交事务
            connection.commit();
            return true;
            
        } catch (SQLException e) {
            try {
                connection.rollback(); // 回滚事务
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
            return false;
        } finally {
            // 关闭资源
            try {
                if (sourceRs != null) sourceRs.close();
                if (sourceStmt != null) sourceStmt.close();
                if (destRs != null) destRs.close();
                if (destStmt != null) destStmt.close();
                connection.setAutoCommit(true); // 恢复自动提交模式
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    // 不要修改main() 
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        Class.forName(JDBC_DRIVER);
        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

        while(sc.hasNext()) {
            String input = sc.nextLine();
            if(input.equals("")) break;

            String[] commands = input.split(" ");
            if(commands.length == 0) break;
            
            String payerCard = commands[0];
            String payeeCard = commands[1];
            double amount = Double.parseDouble(commands[2]);
            
            if (transferBalance(connection, payerCard, payeeCard, amount)) {
                System.out.println("转账成功。");
            } else {
                System.out.println("转账失败,请核对卡号，卡类型及卡余额!");
            }
        }
    }
}
```